* Preface

This is an experiment to find out whether literate configurations in a
single monolithic org-mode file actually have a perceivable benefit.

I'm using this configuration on a system running Arch Linux and Emacs
24.4, that's why this configuration will be using the latest and
greatest features and /not/ check for the system it's running on.
While I do use =emacsclient= for most of my editing needs, I
occasionally open =emacs= instances for things like IRC or testing
purposes.

* Init

** User Interface

Emacs comes with a set of pretty wonky defaults, since the UI is what
we'll see first, we'll deal with it swiftly.  Part of its
configuration can be set up in =~/.Xresources= and has the effect to
be used before any frame is displayed for the price of less
flexibility.  For experimentation, reload such configuration with
=xrdb ~/.Xresources=.  Keep in mind that this hack might not do
anything for you on a sufficiently fast machine that loads themes
faster than you can notice.

*** Superfluous UI elements

I prefer not dealing with menu bars, tool bars and scroll bars and
deactivate them in =~/.Xresources=:

#+BEGIN_SRC conf
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
#+END_SRC

*** Stop cursor blinking

This used to give me nightmares, especially with the 24.4 addition
that made the cursor blink ten times, then stops blinking until moving
it again.

#+BEGIN_SRC conf
Emacs.cursorBlink: off
#+END_SRC

*** Less jarring background change

The default background color chosen is white, however I'm using a dark
theme.  Changing the background color after frame creation results in
flashing, therefore I modify the background color to equal the one of
the theme I'm going to load later.

#+BEGIN_SRC conf
Emacs.background: #002b36
#+END_SRC

The only other UI element left that stays visible throughout the
entire init time would be the mode line.  It took me a bit of puzzling
to figure out the right format for making it look the same as in my
theme, but I eventually figured out from reading the last paragraph of
the =(emacs) Table of Resources= info node that it does read in a list
from a string by studying the sources of =faces.el= and =xfaces.c=.
While this sounds kind of obvious, it means one can debug errors for
more complex values like the one for the box by simply invoking
~read-from-string~ on them.

#+BEGIN_SRC conf
Emacs.mode-line.attributeForeground: #93a1a1
Emacs.mode-line.attributeBackground: #002b36
Emacs.mode-line.attributeBox: (:line-width 1 :color "#073642")
#+END_SRC

*** Load theme

My theme is a heavily customized Solarized Dark, originally taken from
Bozhidar Batsov, later rewritten to support additional modes, the
16-color palette in terminals and variant toggling.  It's stored in a
separate file, to accomodate for that fact we need to customize a
variable for user-made themes.

#+BEGIN_SRC emacs-lisp
(setq custom-theme-directory "~/.emacs.d/theme")
(load-theme 'my-solarized t)
#+END_SRC

Let's disable questions about theme loading while we're at it.

#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)
#+END_SRC

Tooltips can be themed as well.

#+BEGIN_SRC emacs-lisp
(setq x-gtk-use-system-tooltips nil)
#+END_SRC

*** Improve the mode line

=smart-mode-line= is pretty awesome!

#+BEGIN_SRC emacs-lisp
(setq sml/theme 'automatic
      sml/mode-width 'full
      sml/replacer-regexp-list
      '(("^~/org/" ":O:")
        ("^~/\\.emacs\\.d/" ":ED:")))
#+END_SRC

However I prefer hiding minor modes by default.

#+BEGIN_SRC emacs-lisp
(setq rm-blacklist ".*")
#+END_SRC

*** Disable advertisements

The first obvious thing one notices upon launching an uncustomized
Emacs is a rather fancy splash screen that informs you about the usage
and advertises for the GNU project.  I did eventually grew annoyed by
it.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

A less obvious one is the advertisement message displayed after
successful startup in the echo area.  The culprit behind it is
~display-startup-echo-area-message~ and goes great lengths to make
sure it's seen by first checking whether the
~inhibit-startup-echo-area-message~ has been set by the =customize=
system to your user name, then scanning your init file with a regular
expression for it.  Considering I dislike using the =customize=
system, don't have a conventional init file and find this pretty
silly, I disable this behaviour entirely by redefining the function to
display a bit more encouraging message instead.

#+BEGIN_SRC emacs-lisp
(defun display-startup-echo-area-message ()
  (message "Let the hacking begin!"))
#+END_SRC emacs-lisp

*** Fix the display of Emoji

After starting to use Emacs for IRC I've discovered that unlike
everything else on my system using the excellent =fontconfig= software
it fails displaying Emoji such as the infamous PILE OF POO (ðŸ’©) out of
the box.  I'm afraid I will never find out the exact details of its
font fallback mechanism which might be for the better.  To fix this
for both Emacs and Emacsclient for all font sizes I had to set up a
fontset consisting of my favourite monospaced and a suitable fallback
font in both X resources and my init file.

#+BEGIN_SRC conf
Emacs.Fontset-0: -*-DejaVu Sans Mono-*-*-*-*-14-*-*-*-*-*-fontset-dejavu14, symbol:-*-DejaVu Sans-*-*-*-*-14-*-*-*-*-*-*, symbol:-*-Symbola-*-*-*-*-14-*-*-*-*-*-*
Emacs.font: fontset-dejavu14
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq default-frame-alist '((font . "DejaVu Sans Mono-10.5")))
(defun my-fix-emojis (&optional frame)
  (set-fontset-font "fontset-default" '(#x10000 . #x1ffff) "Symbola" frame))
(my-fix-emojis)
(add-hook 'after-make-frame-functions 'my-fix-emojis)
#+END_SRC

*** Adjust keystroke echo timeout

This is a built-in feature I didn't expect to be useful.  If you type
part of keybind, Emacs will display this part in the echo area after a
timeout.  One second is a bit too long though for my taste.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5)
#+END_SRC

** Emacs annoyances

Every file stating "This file is part of GNU Emacs." is more often
than not a source of code that may be crufty, nausea-inducing or just
having weird defaults that I need to correct.

*** Memory Management

Let's allow more than 800 KiB cache before starting garbage collection.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 50000000)
#+END_SRC

*** Fix ~line-number-mode~

~line-number-mode~ displays the current line number in the mode line,
however it stops doing that in buffers when encountering at least one
overly long line and displays two question marks instead.  This is
pretty unhelpful, the only workaround I've been able to find was to
increase ~line-number-display-width~ to a substantially higher value.

#+BEGIN_SRC emacs-lisp
(setq line-number-display-limit-width 10000)
#+END_SRC

See also [[http://emacs.stackexchange.com/questions/3824/what-piece-of-code-in-emacs-makes-line-number-mode-print-as-line-number-i][this question]] on the Emacs SE.

*** GnuTLS

I have no idea why, but apparently you get nasty warnings by the
GnuTLS library upon using https with the default settings.  Increasing
the minimum prime bits size to something safer alleviates that.

#+BEGIN_SRC emacs-lisp
(setq gnutls-min-prime-bits 4096)
#+END_SRC

*** Scratch

Since the =*scratch*= buffer is pretty hard-wired into Emacs (see
=buffer.c=), the least we could do is getting rid of its initial
message.

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "")
(setq initial-major-mode 'emacs-lisp-mode)
#+END_SRC

*** Initial buffer

However I don't want to see the scratch buffer, let's display our
notes file instead as daily reminder what's left to do.

#+BEGIN_SRC emacs-lisp
(setq remember-notes-initial-major-mode 'org-mode)
(setq initial-buffer-choice 'remember-notes)
#+END_SRC

*** Find C functions

There's a fair number of Emacs functions that aren't written in Emacs
Lisp.  To be able to locate them, it's necessary to grab a tarball of
the sources and put it into a specific location.  To recreate these,
grab the latest tarball from http://ftp.gnu.org/gnu/emacs/, extract
its contents and put the =src= directory into =~/.emacs.d=, then
customize the following variable.

#+BEGIN_SRC emacs-lisp
(setq find-function-C-source-directory "~/.emacs.d/src")
#+END_SRC

*** Shorten Yes/No prompts

Per default you're required to type out a full "yes" or "no" whenever
the function ~yes-or-no-p~ is invoked, let's substitute its function
definition to allow a "y" or "n" without even requiring confirmation.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Open URLs with =xdg-open=

I've set up =xdg-open= to use my prefered browser for HTTP and HTTPS
URLs.  Emacs claims to detect whether my system can use it, however
this fails because I don't have a popular DE up and running (I kid you
not, look at ~browse-url-can-use-xdg~ and how it replicates that part
from the =xdg-open= script).

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-xdg-open)
#+END_SRC

*** Zero out default splitting tresholds

I have no idea how this actually works, but it seems to make Emacs
prefer doing a horizontal split over a vertical split on wide screens.

#+BEGIN_SRC emacs-lisp
(setq split-height-threshold 0
      split-width-threshold 0)
#+END_SRC

*** Unique buffer names

This shouldn't be necessary since I'm already using =smart-mode-line=,
however it's better to use a less confusing style than the default
that puts brackets around the buffer names shared in Emacs.

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

*** Inhibit =custom= littering my init file

For whatever reason the customization system will write into your init
file which is especially annoying if you have it in version control
like I do.  It's reasonably simple to deactivate this behaviour by
customizing customize into using a dedicated file, however you'll need
to both delete the lines it wrote and load it afterwards to make it
aware it has already been loaded successfully.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/etc/custom.el")
(load custom-file)
#+END_SRC

*** Display .nfo files with appropriate code page

Since Emacs auto-detection of encodings is quite good, but not
omniscient, we'll give it a nudge to display these files the way
they're supposed to be.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-coding-alist '("\\.nfo\\'" . ibm437))
#+END_SRC

*** Fix scrolling

Half-page scrolling is great at reducing bandwidth, but is very
jarring when done automatically.  The following settings will make
Emacs scroll line by line, without scrolloff and try to keep point at
the same visual place when scrolling by page.

#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 10000
      scroll-preserve-screen-position t)
#+END_SRC

*** Indent with spaces by default

Most programming languages I work with prefer spaces over tabs.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

*** Manage Backup and autosave files

Backup files are created on save in the same directory as the file and
end in =~=.  They can be numbered which makes most sense combined with
a different save location and automatic pruning.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq version-control t)
(setq delete-old-versions t)
#+END_SRC

Autosave files are created between saves after a sufficient timeout in
the current directory for crash detection, they begin and end with
=#=.  Let's change their save location as well.

#+BEGIN_SRC emacs-lisp
(setq auto-save-list-file-prefix "~/.emacs.d/autosave/")
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

Keep in mind that there is nothing you can do regarding lock files
except deactivating them completely (which robs you of the ability to
detect session clashes).  They are symlinks that are created upon
modification of the file in question in its directory and are prefixed
by =.#=.  Saving the file makes them disappear (unlike autosave
files).

*** Allow for multiple Emacs daemons

Although I'm pretty sure I won't make use of this, I prefer using
local TCP connections over socket files.  Another benefit of this
setting is that it would allow me to make use of =emacsclient=
to access a remote Emacs daemon.

#+BEGIN_SRC emacs-lisp
(setq server-use-tcp t)
#+END_SRC

*** Stop pasting at the mouse click point

Middle-clicking is nice to paste, however it should not adjust point
and paste at the then adjusted point.

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)
#+END_SRC

*** Display buffer name in frame titles

The default is to display the invocation name and host.  Changing that
to use a different separator and the buffer name is trivial, however
there's still an annoying space in front when using =M-:=.  Regular
expressions to the rescue!

#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '("" invocation-name ": " (:eval (replace-regexp-in-string
                                        "^ +" "" (buffer-name)))))
#+END_SRC

*** Disable parentheses blinking on entering a match

This will be done by a different package anyways, therefore we don't
need it.

#+BEGIN_SRC emacs-lisp
(setq blink-matching-paren nil)
#+END_SRC

*** Display fringe indicators in ~visual-line-mode~

It's pretty nice to have the option to display words in a buffer as if
they were hardwrapped around the word boundaries, however it's
confusing to not have any fringe indicators.

#+BEGIN_SRC emacs-lisp
(setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC

*** Enable every deactivated command

The rationale for this default seems to be to avoid confusion for
beginners, I personally find it kind of annoying that Emacs of all
editors does this kind of thing and doesn't offer a straightforward
option to disable it even.

#+BEGIN_SRC emacs-lisp
(mapatoms (lambda (s) (when (get s 'disabled) (put s 'disabled nil))))
#+END_SRC

*** Save clipboard data of other programs in the kill ring when possible

I hope the necessity of this will be gone once Wayland is a viable
option for me.

#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC

*** Make recentering behave more similiar to other programs

Try it out yourself by hitting =C-l=, it will start with the top
instead of the middle row.

#+BEGIN_SRC emacs-lisp
(setq recenter-positions '(top middle bottom))
#+END_SRC

*** Make =kill -USR1= do something useful

A lesser known fact is that sending the =USR2= signal to an Emacs
process makes it proceed as soon as possible to a debug window.
=USR1= is ignored however, so let's bind it to an alternative
desirable function that can be used on an Emacs instance that has
locked up.

#+BEGIN_SRC emacs-lisp
(defun my-quit-emacs-unconditionally ()
  (interactive)
  (my-quit-emacs '(4)))

(define-key special-event-map (kbd "<sigusr2>") 'my-quit-emacs-unconditionally)
#+END_SRC

** Packages bundled with Emacs

This includes stuff that is bundled with Emacs and can be obtained
from a more recent source as well, such as =org-mode=.  I'm mostly
refering to smaller packages though.

*** =recentf=

~recentf-mode~ allows you to access the list of recent files which can
be used by =ido= and =helm=.  Let's save its file somewhere else and
change the size of its history while we're at it.

#+BEGIN_SRC emacs-lisp
(setq recentf-save-file "~/.emacs.d/etc/recentf"
      recentf-max-saved-items 50)
#+END_SRC

*** =savehist=

The history of prompts like =M-:= can be saved, but let's change its
save file and history length first.

#+BEGIN_SRC emacs-lisp
(setq savehist-file "~/.emacs.d/etc/savehist"
      history-length 150)
#+END_SRC

*** =save-place=

I didn't expect to like this functionality, but it's pretty neat to
start from the last place you were in a file the next time you visit
it.  Asides from putting the save file somewhere else, I have to
enable this behaviour for every buffer since it's buffer-local.

#+BEGIN_SRC emacs-lisp
(setq-default save-place t)
(setq save-place-file "~/.emacs.d/etc/saveplace")
#+END_SRC

*** =windmove=

The =windmove= provides useful commands for moving window focus by
direction, I prefer having wraparound instead of getting errors
though.

#+BEGIN_SRC emacs-lisp
(setq windmove-wrap-around t)
#+END_SRC

*** =bookmark=

Yet another file that I prefer being saved somewhere else.

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file "~/.emacs.d/etc/bookmarks")
#+END_SRC

*** =ediff=

Anything else than =emacsclient= spawning frames is pretty much
useless for me with =i3=.  I assume the vertical split is not done
because I've customized horizontal splits to be prefered.  The name of
the alternative splitting function is not a mistake, what Emacs calls
"horizontal" in =window.el= is called vertical in anything else.

#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

*** =debug=

The debugger does display only the position of point when evaluating
buffers, the following rendition of =debug-setup-buffer= displays a
line number as well.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'debug
  (defun debugger-setup-buffer (debugger-args)
    "Initialize the `*Backtrace*' buffer for entry to the debugger.
That buffer should be current already."
    (setq buffer-read-only nil)
    (erase-buffer)
    (set-buffer-multibyte t)		;Why was it nil ?  -stef
    (setq buffer-undo-list t)
    (let ((standard-output (current-buffer))
          (print-escape-newlines t)
          (print-level 8)
          (print-length 50))
      (backtrace))
    (goto-char (point-min))
    (delete-region (point)
                   (progn
                     (search-forward "\n  debug(")
                     (forward-line (if (eq (car debugger-args) 'debug)
                                       2	; Remove implement-debug-on-entry frame.
                                     1))
                     (point)))
    (insert "Debugger entered")
    ;; lambda is for debug-on-call when a function call is next.
    ;; debug is for debug-on-entry function called.
    (pcase (car debugger-args)
      ((or `lambda `debug)
       (insert "--entering a function:\n"))
      ;; Exiting a function.
      (`exit
       (insert "--returning value: ")
       (setq debugger-value (nth 1 debugger-args))
       (prin1 debugger-value (current-buffer))
       (insert ?\n)
       (delete-char 1)
       (insert ? )
       (beginning-of-line))
      ;; Debugger entered for an error.
      (`error
       (insert "--Lisp error: ")
       (prin1 (nth 1 debugger-args) (current-buffer))
       (insert ?\n))
      ;; debug-on-call, when the next thing is an eval.
      (`t
       (insert "--beginning evaluation of function call form:\n"))
      ;; User calls debug directly.
      (_
       (insert ": ")
       (prin1 (if (eq (car debugger-args) 'nil)
                  (cdr debugger-args) debugger-args)
              (current-buffer))
       (insert ?\n)))
    ;; After any frame that uses eval-buffer,
    ;; insert a line that states the buffer position it's reading at.
    (save-excursion
      (let ((tem eval-buffer-list))
        (while (and tem
                    (re-search-forward "^  eval-\\(buffer\\|region\\)(" nil t))
          (beginning-of-line)
          (insert (format "Error at line %d in %s: "
                          (with-current-buffer (car tem)
                            (line-number-at-pos (point)))
                          (with-current-buffer (car tem)
                            (buffer-name))))
          (pop tem))))
    (debugger-make-xrefs)))
#+END_SRC

*** =dired=

For the few times I'm using Dired, I prefer it not spawning an endless
amount of buffers.  In fact, I'd prefer it using one buffer unless
another one is explicitly created, but you can't have everything.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))
#+END_SRC

*** =tramp=

If TRAMP makes backup files, they should better be kept locally than
remote.

#+BEGIN_SRC emacs-lisp
(setq tramp-backup-directory-alist backup-directory-alist)
#+END_SRC

As usual I want to fix up the file it's storing its history in.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tramp-cache
  (setq tramp-persistency-file-name "~/.emacs.d/etc/tramp"))
#+END_SRC

*** Calendar

General functionality for calendars inside Emacs, split up in a lot of
files.  Customizing it will affect other packages, including =calfw=.
The following customizations make it appear german (since I happen to
live in Germany, d'uh).

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
      calendar-day-name-array ["Sonntag" "Montag" "Dienstag" "Mittwoch"
                               "Donnerstag" "Freitag" "Samstag"]
      calendar-month-name-array ["Januar" "Februar" "MÃ¤rz" "April" "Mai"
                                 "Juni" "Juli" "August" "September"
                                 "Oktober" "November" "Dezember"])
(setq solar-n-hemi-seasons
      '("FrÃ¼hlingsanfang" "Sommeranfang" "Herbstanfang" "Winteranfang"))

(setq holiday-general-holidays
      '((holiday-fixed 1 1 "Neujahr")
        (holiday-fixed 5 1 "1. Mai")
        (holiday-fixed 10 3 "Tag der Deutschen Einheit")))

(setq holiday-christian-holidays
      '((holiday-float 12 0 -4 "1. Advent" 24)
        (holiday-float 12 0 -3 "2. Advent" 24)
        (holiday-float 12 0 -2 "3. Advent" 24)
        (holiday-float 12 0 -1 "4. Advent" 24)
        (holiday-fixed 12 24 "Weihnachten")
        (holiday-fixed 12 25 "1. Weihnachtstag")
        (holiday-fixed 12 26 "2. Weihnachtstag")
        (holiday-fixed 1 6 "Heilige Drei KÃ¶nige")
        (holiday-easter-etc -48 "Rosenmontag")
        (holiday-easter-etc -3 "GrÃ¼ndonnerstag")
        (holiday-easter-etc -2 "Karfreitag")
        (holiday-easter-etc 0 "Ostersonntag")
        (holiday-easter-etc +1 "Ostermontag")
        (holiday-easter-etc +39 "Christi Himmelfahrt")
        (holiday-easter-etc +49 "Pfingstsonntag")
        (holiday-easter-etc +50 "Pfingstmontag")
        (holiday-easter-etc +60 "Fronleichnam")
        (holiday-fixed 8 15 "Mariae Himmelfahrt")
        (holiday-fixed 11 1 "Allerheiligen")
        (holiday-float 11 0 1 "Totensonntag" 20)))

(setq holiday-oriental-holidays nil
      holiday-bahai-holidays nil
      holiday-islamic-holidays nil
      holiday-hebrew-holidays nil)
#+END_SRC

*** =which-func-mode=

#+BEGIN_SRC emacs-lisp
(setq which-func-modes '(org-mode))
#+END_SRC

*** =org-mode=

First some UI and editing tweaks.

#+BEGIN_SRC emacs-lisp
(setq org-catch-invisible-edits 'error
      org-startup-indented t
      org-cycle-include-plain-lists 'integrate
      org-ellipsis " [â€¦]"
      org-return-follows-link t
      org-M-RET-may-split-line nil
      org-src-fontify-natively t
      org-enforce-todo-dependencies t
      org-enforce-todo-checkbox-dependencies t
      org-link-frame-setup '((file . find-file)))
#+END_SRC

I like taking notes and sometimes even take a look at the agenda.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/"
      org-agenda-files (list org-directory)
      org-default-notes-file "~/org/inbox.org"
      org-capture-templates
      '(("n" "Note" entry (file+headline "~/org/inbox.org" "Inbox")
         "* TODO %<%Y-%m-%d %H:%M:%S>\n\n%?" :empty-lines 1)
        ("p" "PW" entry (file+headline "~/org/pw.org" "PW")
         "* TODO %<%Y-%m-%d %H:%M:%S>\n\n%?" :empty-lines 1)
        ("w" "Work" entry (file+datetree "~/org/work.org")
         "* %<%H:%M>\n\n%?" :empty-lines 1)
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
         "* %<%H:%M>\n\n%?" :empty-lines 1)))
#+END_SRC

To keep track how much I wrote when taking a note, I enable a word
counting minor mode.  Upstream didn't autoload its entry point for
Reasonsâ„¢ which is why I do that myself.

#+BEGIN_SRC emacs-lisp
(autoload 'wc-mode "wc-mode" "Enable wc-mode" t)
(add-hook 'org-capture-mode-hook 'wc-mode)
#+END_SRC

The export functionality is very handy, but some of the stuff I like
using is deactivated by default :<

#+BEGIN_SRC emacs-lisp
(setq org-export-backends '(ascii beamer html latex md))
#+END_SRC

*** =comint=

Here comes another particularly interesting Emacs package.  It allows
one to define major modes interacting with a REPL-style process.  In
other words, it gives you all kinds of shell and interpreter
interaction with common keybindings, be it for SQL, your favourite
programming language or your shell.  Even Emacs itself can be used,
try out =M-x ielm=.

However there's a couple things that could be improved.  One of them
is the fact that by default such buffers are editable.  The prompt can
be customized easily to be read-only, the remaining output needs a bit
more work.

#+BEGIN_SRC emacs-lisp
(setq comint-prompt-read-only t)

(defun my-comint-preoutput-read-only (text)
  (propertize text 'read-only t))

(add-hook 'comint-preoutput-filter-functions
          'my-comint-preoutput-read-only)
#+END_SRC

While it would be better to patch ~comint-previous-input~ (which is
used by ~comint-next-input~ with a negative argument, so don't worry)
to take a customizable value that determines whether to wrap around or
not, I've hacked it into just wrapping around for simplicity's sake.

#+BEGIN_SRC emacs-lisp
(defun comint-previous-input (arg)
  "Cycle backwards with wrap-around through input history, saving input."
  (interactive "*p")
  (unless (and (eq comint-input-ring-index nil)
               (< arg 0))
    (if (and (eq comint-input-ring-index 0)
             (< arg 0)
             comint-stored-incomplete-input)
        (comint-restore-input)
      (unless (and (eq comint-input-ring-index
                       (- (ring-length comint-input-ring) 1))
               (> arg 0))
        (comint-previous-matching-input "." arg)))))
#+END_SRC

It's trivial to clear the entire =comint= buffer by temporarily
binding ~comint-buffer-maximum-size~ to zero and calling
~comint-truncate-buffer~, however that's not what I really want.
Usually it's just the output of the last expression that's been
faulty and needs to be cleared by replacing it with a comment.  The
idea itself is taken from [[https://github.com/clojure-emacs/cider/blob/cb3509eb54d3c3369681d73f3218a1493b977e99/cider-repl.el#L640-L655][CIDER]].

#+BEGIN_SRC emacs-lisp
(defun my-comint-last-output-beg ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'field) 'boundary)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (if (= (point) (point-min))
        (point)
      (1+ (point)))))

(defun my-comint-last-output-end ()
  (save-excursion
    (comint-goto-process-mark)
    (while (not (or (eq (get-char-property (point) 'font-lock-face)
                        'comint-highlight-prompt)
                    (= (point) (point-min))))
      (goto-char (previous-char-property-change (point) (point-min))))
    (let ((overlay (car (overlays-at (point)))))
      (when (and overlay (eq (overlay-get overlay 'font-lock-face)
                             'comint-highlight-prompt))
        (goto-char (overlay-start overlay))))
    (1- (point))))

(defun my-comint-clear-last-output ()
  (interactive)
  (let ((start (my-comint-last-output-beg))
        (end (my-comint-last-output-end)))
    (let ((inhibit-read-only t))
      (delete-region start end)
      (save-excursion
        (goto-char start)
        (insert (propertize "output cleared"
                            'font-lock-face 'font-lock-comment-face))))))
#+END_SRC

Killed =comint= processes tend to leave an useless buffer around.
Let's kill it after noticing such an event with a process sentinel.

#+BEGIN_SRC emacs-lisp
(defun my-shell-kill-buffer-sentinel (process event)
  (when (memq (process-status process) '(exit signal))
    (kill-buffer)))

(defun my-kill-process-buffer-on-exit ()
  (set-process-sentinel (get-buffer-process (current-buffer))
                        #'my-shell-kill-buffer-sentinel))

(dolist (hook '(ielm-mode-hook term-exec-hook comint-exec-hook))
  (add-hook hook 'my-kill-process-buffer-on-exit))
#+END_SRC

Recentering feels a bit unintuitive since it goes by the middle
first.  I only need top and bottom commands, for that I'll define my
own command and bind it later.

#+BEGIN_SRC emacs-lisp
(defun my-recenter-top-bottom ()
  (interactive)
  (goto-char (point-max))
  (let ((recenter-positions '(top bottom)))
    (recenter-top-bottom)))
#+END_SRC

Another thing annoying me in comint buffers is that when text is
read-only, both cursor movement and appending to kill ring still
happen.  This is less useful since if you keep holding the keys to
delete words, you end up traversing the entire buffer instead of
stopping at the read-only boundaries and pollute the kill ring.  To
remedy that I'll write my own word killing commands in the typical
Emacs user fashion, however I'll not advise the built-ins since who
knows what might possibly be relying on this default behaviour.

#+BEGIN_SRC emacs-lisp
(defun my-kill-word (arg)
  (interactive "p")
  (unless buffer-read-only
    (let ((beg (point))
          (end (save-excursion (forward-word arg) (point)))
          (point (save-excursion (goto-char (next-single-char-property-change
                                             (point) 'read-only))
                                 (point))))
      (unless (get-char-property (point) 'read-only)
        (if (< point end)
            (kill-region beg point)
          (kill-region beg end))))))

(defun my-backward-kill-word (arg)
  (interactive "p")
  (my-kill-word (- arg)))
#+END_SRC

The new functionality introduced has to be bound to keys for
convenient use.  Note the remapping of commands.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'comint
  (define-key comint-mode-map [remap kill-word] 'my-kill-word)
  (define-key comint-mode-map [remap backward-kill-word] 'my-backward-kill-word)
  (define-key comint-mode-map (kbd "C-S-l") 'my-comint-clear-last-output)
  (define-key comint-mode-map (kbd "C-l") 'my-recenter-top-bottom))
#+END_SRC

*** =shell=

For unknown reasons I get my input echoed back to me.  In other words,
sending =ls= to =shell= echoes my input twice, then the output.
=comint= has a setting that can filter these echoes.

#+BEGIN_SRC emacs-lisp
(defun my-shell-turn-echo-off ()
  (setq comint-process-echoes t))

(add-hook 'shell-mode-hook 'my-shell-turn-echo-off)
#+END_SRC

*** =eshell=

I want =C-d= to not unconditionally delete the character, but to quit
on an empty prompt, too.

#+BEGIN_SRC emacs-lisp
(defun my-eshell-quit-or-delete-char (arg)
  (interactive "p")
  (if (and (eolp) (looking-back eshell-prompt-regexp))
      (eshell-life-is-too-much) ; wtf
    (delete-forward-char arg)))

(defun my-eshell-setup ()
  (define-key eshell-mode-map (kbd "C-d") 'my-eshell-quit-or-delete-char))

(add-hook 'eshell-mode-hook 'my-eshell-setup)
#+END_SRC

For silly reasons I like having a rainbow-colored prompt.

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-load-hook 'nyan-prompt-enable)
#+END_SRC

** Packages outside Emacs

Welcome to the blind spot of =emacs-devel=.  Unlike the people on
there, I'll not pretend external packages are something to speak of in
hushed tones.

*** Smex

Nice improvement over vanilla =M-x= that gives you persistency and
better matching.  Let's give it more history and a different file.

#+BEGIN_SRC emacs-lisp
(setq smex-save-file (concat user-emacs-directory "etc/smex")
      smex-history-length 50)
#+END_SRC

*** CSV

After installing =csv-mode= from GNU ELPA, I found out it's using a
=:set= form in its customization option for the separators, therefore
I had to figure out what "internal" variables they were setting and
customized them.

#+BEGIN_SRC emacs-lisp
(setq csv-separators '(";" "	" ",")
      csv-separator-chars '(?\; ?	 ?,)
      csv--skip-regexp "^
;	,"
      csv-separator-regexp "[;	,]"
      csv-font-lock-keywords '(("[;	,]" (0 'csv-separator-face))))
#+END_SRC

*** Quelpa

This is necessary to have updates going on.

#+BEGIN_SRC emacs-lisp
(setq quelpa-upgrade-p t)
#+END_SRC

*** Shackle

The only thing to configure is its rules.

#+BEGIN_SRC emacs-lisp
(setq shackle-rules
      '((svg-2048-mode :same t)
        ("*Help*" :align t :select t)
        ("\\`\\*helm.*?\\*\\'" :regexp t :align t :ratio 0.4 :defer t)
        (compilation-mode :noselect t)
        (inferior-scheme-mode :popup t)
        (t :select t)))
#+END_SRC

*** Company

The following sets up a good amount of UI tweaks and everything
necessary for the global backends.  It's possible to make
~company-backends~ buffer-local and allow mixing backends as most fit
per mode to allow for something like =yasnippet= integration.

#+BEGIN_SRC emacs-lisp
(setq company-idle-delay 0.1
      company-minimum-prefix-length 2
      company-selection-wrap-around t
      company-show-numbers t
      company-require-match 'never
      company-dabbrev-downcase nil
      company-dabbrev-ignore-case t
      company-backends '(company-jedi company-nxml
                                      company-css company-capf
                                      (company-dabbrev-code company-keywords)
                                      company-files company-dabbrev)
      company-jedi-python-bin "python")
#+END_SRC

Sometimes it's useful to narrow down the candidate list if it's overly
long with something better than =C-s=.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'company
  (define-key company-active-map (kbd "C-:") 'helm-company))
#+END_SRC

*** Dash

Very useful library, too bad I don't know how to properly use it yet.
Since it's sprinkled all over in code I'd like to have extra syntax
highlighting for it.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'dash
  (dash-enable-font-lock))
#+END_SRC

*** Helm

A polarizing package to say the least.  The good part of it is that it
actually tries enabling abstractions over complex selection UI.  The
bad part is that it's overly complex, hard to debug and prone to
bizarre behaviour.  I've handed in ten bugs for it already and don't
expect those to be the last.  With that being said I find it essential
to quickly find your way through Emacs, I just wish it were less
idiosyncratic and with developer documentation.

The default navigation isn't as fast as it could be.  Automatically
switching directories is a must for me.  Note the hack with
~helm-ff--auto-update-state~, it's supposedly internal, but only set
after using ~helm-find-files~ which essentially means that everything
using the file selector won't get the auto-switching goodies unless a
file has been found before.  With this hack however it will.  The
other hack goes beyond the ~helm-ff-ido-style-backspace~ customization
and unconditionally enables backspace going up one level in both kinds
of file selectors.

#+BEGIN_SRC emacs-lisp
(setq helm-ff-ido-style-backspace 'always
      helm-ff-auto-update-initial-value t
      helm-ff--auto-update-state t)

(with-eval-after-load 'helm-files
  (define-key helm-read-file-map (kbd "<backspace>")
    'helm-find-files-up-one-level)
  (define-key helm-find-files-map (kbd "<backspace>")
    'helm-find-files-up-one-level))
#+END_SRC

There are more idiosyncracies to be resolved with file selection.  I
don't want to see boring files and not get prompted for creating a new
file either.  The creation of a new directory however is kept as is.

#+BEGIN_SRC emacs-lisp
(setq helm-ff-newfile-prompt-p nil
      helm-ff-skip-boring-files t)
#+END_SRC

Highlighting of token matches is a tad slow, let's speed it up.

#+BEGIN_SRC emacs-lisp
(setq helm-mp-highlight-delay 0.3)
#+END_SRC

=grep= is very fast, but not the best tool for code search, especially
not within compressed files.  That's why I'll go for =ag= instead, its
=-z= option enables the usage of the very great libarchive.  For
=helm= to recognize the matches properly I need to enable line numbers
and columns in its output, something the =--vimgrep== option (the
irony) does.  Another subtle hack hidden in here is deliberately using
the recursing variant for both types of searches, this might break
something, but so far hasn't shown any obvious side-effects

#+BEGIN_SRC emacs-lisp
(setq helm-grep-default-command "ag --vimgrep -z %p %f"
      helm-grep-default-recurse-command "ag --vimgrep -z %p %f")
#+END_SRC

For whatever reason ~find-library~ isn't used properly with
~helm-mode~ enabled, adding a read handler fixes this.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm-mode
  (add-to-list 'helm-completing-read-handlers-alist
               '(find-library . helm-completing-read-with-cands-in-buffer)))
#+END_SRC

I like having my dotfiles repo as default when using =helm-cmd-t= on a
directory that's not under version-control.

#+BEGIN_SRC emacs-lisp
(setq helm-cmd-t-default-repo "~/code/dotfiles")
#+END_SRC

I dislike =helm= taking over tab-completion in my IRC client.

#+BEGIN_SRC emacs-lisp
(setq helm-mode-no-completion-in-region-in-modes
      '(circe-channel-mode
        circe-query-mode
        circe-server-mode))
#+END_SRC

** Keybinds

We already have =F1= for help, so let's turn =C-h= and =M-h= more
readline-like.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h") 'delete-backward-char)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+END_SRC

Deactivate all other uses of insert than =Shift-Insert=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<insert>") nil)
(global-set-key (kbd "S-<insert>") nil)
#+END_SRC

Install a keybind that saves all buffers with asking (use a prefix
argument to inhibit the questions), then kills Emacs (including the
daemon) on =M-<f4>=.

#+BEGIN_SRC emacs-lisp
(defun my-quit-emacs (arg)
  (interactive "P")
  (save-some-buffers (when (consp arg) t) t)
  (kill-emacs))

(global-set-key (kbd "M-<f4>") 'my-quit-emacs)
#+END_SRC

Make =M-x= more useful, put its original functionality on =C-c M-x=
instead.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-smex)
(global-set-key (kbd "C-c M-x") 'execute-extended-command)
#+END_SRC

Helm stuff

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-x b") 'helm-buffers-list)
(global-set-key (kbd "<f10>") 'helm-resume)
#+END_SRC

Org-mode capturing on =<F11>= mirrors inbox look-up on =<F12>=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f11>") 'org-capture)
#+END_SRC

** Hooks

First of all, let's define a list of hooks for everything that's not a
special mode.  This will inevitably contain modes that have not been
properly derived, might be worth reporting those.

#+BEGIN_SRC emacs-lisp
(defvar my-non-special-mode-hooks
  '(text-mode-hook prog-mode-hook css-mode-hook))
#+END_SRC

Then define a function to set up all non-special modes by enabling
fringe indicators, showing trailing whitespace and making underscores
a word character.  This function is added to all of those modes as
hook afterwards.

#+BEGIN_SRC emacs-lisp
(defun my-non-special-modes-setup ()
  (setq indicate-empty-lines t)
  (setq indicate-buffer-boundaries '((top . left) (bottom . left)))
  (setq show-trailing-whitespace t)
  (modify-syntax-entry ?_ "w")
  (goto-address-mode))

(dolist (hook my-non-special-mode-hooks)
  (add-hook hook 'my-non-special-modes-setup))
#+END_SRC

Same deal with programming-related hooks and text-related hooks.

#+BEGIN_SRC emacs-lisp
(defvar my-text-mode-hooks
  '(text-mode-hook css-mode-hook))

(defun my-text-modes-setup ()
  (auto-fill-mode))

(dolist (hook my-text-mode-hooks)
  (add-hook hook 'my-text-modes-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defvar my-prog-mode-hooks
  '(prog-mode-hook))

(defun my-prog-modes-setup ()
  (make-local-variable 'comment-auto-fill-only-comments)
  (setq comment-auto-fill-only-comments t)
  (auto-fill-mode)
  (column-enforce-mode)
  (rainbow-delimiters-mode)) ; TODO move to lispy modes

(dolist (hook my-prog-mode-hooks)
  (add-hook hook 'my-prog-modes-setup))
#+END_SRC

To fine tune completion behavior, I'll prefer ~company-mode~ over
~global-company-mode~.  I should add more hooks for REPLs, too.

#+BEGIN_SRC emacs-lisp
(defvar my-completion-mode-hooks
  '(prog-mode-hook css-mode-hook nxml-mode-hook sgml-mode-hook
    css-mode-hook ielm-mode-hook))

(dolist (hook my-completion-mode-hooks)
  (add-hook hook 'company-mode))
#+END_SRC

** Other

#+BEGIN_SRC emacs-lisp
(defun my-toggle-mode-line-minor-modes ()
  (interactive)
  (if rm-blacklist
      (setq rm-blacklist nil)
    (setq rm-blacklist ".*"))
  (force-mode-line-update))
#+END_SRC

** Packages

Emacs Lisp files can be easily turned into packages one can load and
install via =package.el=.  While initialization is done, it only
happens /after/ successful startup.

Both my setup files and unpublished packages reside in their
respective directories and need to be added to the ~load-path~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/setup")
(add-to-list 'load-path "~/.emacs.d/unpublished")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC

** Unpublished

I have a bunch of stuff I'm working on.  Some of it I can't live
without.

#+BEGIN_SRC emacs-lisp
(require 'helm-smex)
(require 'helm-fkeys)
#+END_SRC

** TODO Unfinished

#+BEGIN_SRC emacs-lisp
(require 'setup-defuns)

;; load remaining setup files
(require 'setup-flycheck)
(require 'setup-helm-fkeys)
(require 'setup-cc-mode)
(require 'setup-lisp)
(require 'setup-web)
(require 'setup-python)
(require 'setup-ruby)
(require 'setup-auctex)
(require 'setup-smartparens)
(require 'setup-evil)
(require 'setup-yasnippet)
(require 'setup-distractions)
#+END_SRC

** Post-Init

While packages were prematurely initialized, the following is
unconditionally run after init has finished.

#+BEGIN_SRC emacs-lisp
(defun my-after-init ()
  (sml/setup)
  (recentf-mode)
  (savehist-mode)
  (require 'saveplace)
  (winner-mode)
  (shackle-mode)
  (smex-initialize)
  (helm-mode)
  (electric-indent-mode -1)
  (which-function-mode)
  (unicode-whitespace-setup)
  (line-number-mode)
  (column-number-mode))
(add-hook 'after-init-hook 'my-after-init)
#+END_SRC

* Epilogue

That's all, folks!
