* Fix Emacs' selection after window quit/close

So very annoying.  Apparently switching window focus after creating
window splits somehow causes a window kill to not select the window's
parent anymore, but instead selects a different window.

Repro: =C-x 3 C-x o C-x o C-x 2 C-x 0=

Result: Switches focus to the other split side instead of the parent
window.

Very likely to be something within ~delete-window-internal~.

* Fix Emacs' window quitting behaviour

This seems to pose a significant issue for implementing interfaces
that pop up buffers and need quitting to just work.  It would be
obvious to implement a FIFO-like structure (see
http://sprunge.us/aGHM), but that's not how it works.  =(info "(elisp)
Window Parameters")= should have the relevant information on
influencing this behaviour.

* Investigate in =recentf= truncation behaviour

Something about it feels off.  It's supposed to remove duplicate
entries first, then truncate if it's still too long, but it feels like
despite a fairly high history length it truncates too many recent
files.  In other words, I want a behaviour comparable to =zsh= and its
history pruning.  In case that's not the reason for it, I'll probably
just increase the history limit to a ridiculously large number.

* Join forces with Fuco and think up better names for the projects to hack on

The plan is to do a Github organization and to learn useful stuff
along the way, such as advanced =dash= usage, EIEIO (an undebuggable
partial implementation of the infamous CLOS) and more abstractions.
The general plan is to reimplement sane subsets of popular packages
since those are assumed to be unfixable with a few pull requests, such
as =helm=, =ace-jump= and many more.

As for the name of this organization, I plead for =tetracat= and
either http://brause.cc/tetracat.jpg or a derived work.  Should be
only a matter of time with a graphics tablet and either Inkscape or
Krita.

* Rewrite a sane subset of =helm=

Let's call it =union= (since there's =unite= for Vim and it's one char
shorter, also there's this very pretty kind of union-jack segment LEDs
of which I happen to have an appropriate animated GIF for).

* Rewrite a sane subset of =dired=

Let's call it =rind= (for =rind= Is Not =dired= or =ranger=-INspired
=dired=).  The reason why should be obvious, =dired='s method of
getting file information by parsing =ls= output is brittle and it's
surprisingly hard to extend.  I really like =ranger=, but it does
neither live within Emacs nor is it able to be extended with elisp.
Fuco's =etable= looks like a good starting place for writing the UI.

* Rewrite a sane subset of =tramp=

I'm not even sure whether that's a good idea at all, let alone how to
test such a thing considering I don't have many remote boxes to try it
on (or to be more precise, just a single one).  It could very well be
that my issues with it arise from its implicit integration into Emacs.

* Rewrite =calfw=

It is pretty much impossible to understand and has bizarre bugs (like,
quitting fucks up position of the window point in the last buffer).
Also, writing your own calendar seems to be good tradition to
experience the many falsehoods programmers believe in about time and
dates yourself.

* Make a list of (REPL) modes to enable =company= for

Stuff like =ielm= would qualify.  Perhaps some textual modes, too.

* Improve elisp completion in =company=

There are a few corner cases (with =company-elisp=, check whether they
are still present in =company-capf=), fix those.  The one annoying me
most is when I'm in a quoted or let-binding list and the completion
assumes that it's first item must be a function which is just wrong.
Additionally to that it would be very cool to have contextual
completion inside macros, like ~loop~ to get the loop keywords as
candidates.

* Learn how =company-capf= works

The elisp backend was replaced by it in 24.4, its code should tell me
enough about the effort involved in getting other backends to use it.
Porting the other ones over will give me completion styles.

* Integrate =yasnippet= into =company=

=company-yasnippet= looks pretty snazzy, the only thing preventing me
from using it is that the official documentation suggests making
=company-backends= buffer-local and change its value in every mode
making use of snippets.

* Write own snippets

I've installed =yasnippet= because at that time I had to write Java
code in a course and didn't feel like using Eclipse.  The default
snippets are a bit problematic though, especially the ones used for
elisp code because they're very short and get triggered even if I
hadn't inserted the text beforehand, so hitting TAB in an already
written line at an arbitrary position where the text before point
makes up a valid snippet abbreviation triggers it.  That's definitely
not ok, part of the solution would be writing my own, the other would
be giving them longer names suitable for tab-completion via =company=.

I should add my whimsy snippets to my Emacs configuration, too.

* Learn the =yasnippet= syntax

http://capitaomorte.github.io/yasnippet/snippet-development.html

* Write a =flx=-like completion style

While there's already =flx= code, I need to find out how completion
styles are implemented and check how slow they'd be with =flx= as is.
If it's not fast enough, write a binary component in CHICKEN and make
it flexible enough for more than just that.

* Reuse binary component from above for =helm= / =ido= matching

This would solve the problem of not having nice and fast flex matching
Ã  la Sublime Text.  The key to this is the combination of fast
submatching (heatmap + optimization that makes use of the reuse of the
string since you usually append a glyph at a time and therefore don't
need to start all over again) as in
http://hergert.me/blog/2013/09/13/fuzzy-searching.html and sorting of
the candidates by criteria that make matches for word boundaries
appear at the top.  I'm afraid the hard part would be rather
integrating it in these tools than writing it.

* Write a pure elisp torrent client

Sounds like a pretty hefty exercise considering a network process that
errors out can cause Emacs to hang up and it doesn't have the
facilities required for writing sparse files exposed (yet, I've found
internal C functions for advancing to arbitrary positions in files,
see =fileio.c= when searching for =lseek=).  It would probably be more
useful to write a proper frontend to an existing torrent client.

* Help out holomorph with his =transmission= UI

Unlike the previous entry this sounds very doable and profitable.

* Fix long lines bug

Oh boy.  My main idea how to fix this properly relies on section 6.3
of
http://soft-dev.org/pubs/html/diekmann_tratt__eco_a_language_composition_editor/.
In other words, keeping track of visual line breaks, using them to
speed up rendering and keeping them up to date.  This will obviously
require hacking on the buffer data structure.

* Bring pixel-level smooth scrolling to Emacs

This is part of the railwaycat OS X Emacs port.  To my surprise the
code enabling it is 99% elisp and a few lines of C in =xdisp.c=.  It
would be very cool if it could be done in 100% elisp, but a small
patch wouldn't hurt either.

https://github.com/railwaycat/emacs-mac-port/blob/dbf18e1269297e3a6ff5441c59419ad234449c16/lisp/term/mac-win.el#L2007-L2402
https://github.com/railwaycat/emacs-mac-port/blob/2e5ff4921e4474713878c587965b7e45a0cd12bf/src/xdisp.c#L16227-L16229

Update: I hope this is not the reason for the C-level hack:

http://lists.gnu.org/archive/html/emacs-devel/2015-04/msg00695.html

* Write a proper CSV viewer/editor

Until that long lines bug is fixed, viewing CSV files is no fun.  To
remedy it for now I thought of writing something like a mixture of
=tabview= and =sc= (and call it =sv-mode= because it's for separated
values).  In other words this displays a truncated viewport where you
can scroll through cells and offers keybinds to edit rows and columns
or change the view to something more useful (such as sorting,
filtering, etc.).

* Try out SVG modeline/margin

forcer suggested on #emacs to do tentacle scrollbars.  This might be
possible by abusing the margin.

Meanwhile, [[https://github.com/ocodo/.emacs.d/blob/master/plugins/ocodo-svg-mode-line.el][someone]] did dig out sabof's svg-mode-line and created
something nicer to look at with it.  I don't really like the idea of
just slapping an image on the left or right side of it and leave the
rest as is because it's about as boring as Firefox Personas.  What
interests me is that text used in SVG isn't subject to explicit
fallback (and fallback works out of the box), another thing to exploit
would be the fact that there's no height restriction, so this could be
used to have a two-line modeline.  While it is possible to replicate
mouse events (the =:map= property in =(info "(elisp) Image
Descriptors")= explains how), I wouldn't really want to waste time on
them.

In case I should reconsider my decision regarding images (like, for a
fun blog post), I'd like to use [[https://chriskempson.github.io/base16/#grayscale][base16+greyscale]] [[http://a.pomf.se/gzkfay.gif][with]] [[http://a.pomf.se/fipnjh.png][a]] [[http://a.pomf.se/uhnkjp.png][tiny]] [[http://a.pomf.se/xdgfuh.png][bit]] [[http://a.pomf.se/wlwhse.png][of]]
[[http://a.pomf.se/uokszd.png][color]] and [[http://2.bp.blogspot.com/-Zosgua6dQ9o/Tz3A0LhPF4I/AAAAAAAABX0/gapxpqgNasE/s1600/Goodnight+Punpun+v01+c01+-+010.png][a cartoon bird]].

* Write some more graphical games

I've had enough fun with SVG (although I should at least finish up the
animation part in =svg-2048=), XPM would be the next thing I'd tackle
(for something like Conway's Game of Life).  By then I should have a
good idea what's better to use and could proceed with other fun games,
such as clones of =xeyes=, =breakout=, =tetris= (replicating TGM3 would
be very cool), something like Tower Defense.  Maybe something
demo-like with procedural graphics.  Maybe go more abstract and whip
up everything necessary to do more advanced games, like stuff
reminiscent of visual novels (although, would they work without
sound?), platformers, bullethell shmups, etc.  Who knows whether one
of those might become the next Emacs killer app.

* Write graphical demos

So far I had a flipbook (see the Quasiconf 2014 files), this could be
abstracted into a video player (which converts the video into frames
beforehand, mind you).  A pixelart editor would be very cool,
especially for things like my demo on http://brause.cc/.  GIF editing
by wrapping =gifsicle= and inserting the created previews could be
better than what Photoshop and GIMP offer.  A fully-featured
SVG/Bitmap editor would be more utopian, but the groundwork for that
is laid with the =svg.el= package (which could become a fast
canvas-like) and proper bitmap embedding support in Emacs 25.1.

http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html

* Create my own starter kit

HollywoodOSâ¢ with SVG and something terminal-looking with lots of text
over it would be a really silly one.  So would be a 1984 one that
makes Emacs look and behave even more arcane than usual (with reduced
colors and all that).

* Write a fast terminal emulator

Perhaps with FFI (not sure whether the official one or skeeto's
approach) and libtsm one could write something considerably faster
than ~ansi-term~, probably not though.

* Write audio demos

This doesn't work very well with external processes at the moment,
though my demo with Overtone for Quasiconf 2014 showed promise.  FFI
might solve it (or not).  It would be super-cool to have something
like a keyboard to play melodies, ideally by driving CSound instead of
Supercollider.  It would be even more cool to turn it into a
keyboard-driven tracker to compose music and tweak synths or create
samples to play.

* Work on helm packages

I'm less happy about =helm-smex=.  It would be a lot better to add a
helm interface to smex directly instead of hacking something that
reuses the data the ido interface creates.

As for new packages using =helm=, I'd like having something slightly
better than my current setup with =dmenu= driving =mpd=.  Another
thing that would be cool to have would be an interface to
http://dict.cc/ and its offline dictionaries with history.  Searching
the package archives and AUR would be better than the Web UI.  Perhaps
replacing all of my search engine usage if it proves to be better
(incremental completion is the problem).  Oh and full-text search on
info manuals, it would be enough to be able to use it on the currently
open node and its children.

* Bump bug reports without replies

According to Eli Zaretskii this should be alright to do after a week
without replies.

* Hand in a bug for ~browse-url-can-use-xdg~

This function is not reliable as it only works on a few select Desktop
Environments and essentially replicates what =xdg-open= is doing
already in a less complete fashion.  Before handing in the bug I've
got to find out how to detect it working in a better fashion.  My
rather naÃ¯ve assumption would be that if there is such a binary, the
Xorg session is running and executing it gives me a return code of
zero, everything's fine.

* Send in a patch for ~debug-setup-buffer~

I've figured out that when evaluating a buffer, this function inserts
the buffer position where the error occurs.  It is possible to turn
that into a line number, making it a button that takes you to the file
would be pretty cool and surely a good candidate for a patch and
mailing list discussion since it makes the =--debug-init= option more
useful.

* Discuss =--debug-init= and why it's not a default

Another candidate for the mailing list.  I am still dumbfounded how
one starts Emacs, gets an error at start, then is told to quit and
start it again with that option to get a backtrace.  Why isn't this
option made default?  There doesn't seem to be any performance
penalty, it can be deactivated after successful init and for the very
unlikely situation that there is stuff relying on it not spawning the
debugger (instead of a generic error window) like batch processing, a
new option to deactivate it could be introduced instead (and the
option itself be deprecated by making it a no-op).

* Investigate into the debugger to make it better

I don't know much about the keybindings yet and am much more
acquainted with =edebug= unfortunately.  Finding out how the =debug=
works would be very cool since it seems to always work, there have
been a few posts about stackframes on the stackexchange.

There is a wonderful screenshot of a Lisp machine where the debugger
runs into a division by zero and displays the faulty expression with
the form causing the error highlighted in bold.  That sounds even
better than displaying a line number and button to jump to since
evaluation does not necessarily happen to a file.

Another thing I'd like to see would be backtraces with less bytecode
in them, for both aesthetical (they take up loads more screen estate)
and practical (they break copy-paste on a null byte for me) reasons.
It is possible to re-evaluate a function to obtain prettier display of
its forms, with byte-compilation most of these are lost.

The not so S-Expression-like display of the stackframes isn't ideal
either, it looks more like functions in other languages than something
lispy.  Why they did that is beyond me.

* Report bugs for not properly derived modes

There are a bunch of modes that ought to be derived from ~text-mode~
and ~prog-mode~, but aren't.  All of those should be reported to make
my hooks section cleaner.

* Fix up the (package-initialize) mess

http://lists.gnu.org/archive/html/emacs-devel/2015-04/msg00620.html

Apparently the quick and dirty "Fix" is inserting this instruction in
your init.el every time you use package.el if it wasn't found
before.  Awesome.  I need to go for my "social" fix and tell
Marmalade, MELPA and GNU ELPA about the problem of explaining newbies
about it.

Update: MELPA already got such a note, GNU ELPA got one as well.
Marmalade, well, Nic Ferrier hates the very idea of using
~package-initialize~ explicitly and everyone doing it, unfortunately
[[https://github.com/nicferrier/elmarmalade/issues/102][the issue thread]] devolved into offtopic.

* Rediscover =org-mode= again after having learned elisp

I've stayed away from =org-mode= from everything else asides note
taking and keeping track of things in README-style files since the
configuration and elisp involved scared me off.  However I'm armed
with everything necessary to embark this part of my Emacs journey
again, so why not go through the agenda, refiling, clocking and many
more to keep track of things again?

* Figure out how =evil= works

All I know so far from cursory glances at the sources is that it does
black magic on keymaps, appears to have implemented a type system for
editing commands with elisp macros and has an actually proper looking
parser for ex commands.  This is kind of intriguing and surely a good
chance to learn advanced concepts.

However the documentation is a bit lacking when it comes to extending
it.  Another issue is that several critical variables are empty at
definition, but filled after startup.  Therefore combined reading of
the sources and inspection of variables while it's running are
necessary to gain understanding in its inner workings.

* Fix =evil-surround=

Its commands are not repeatable which sucks since they are
comparatively long.  Another annoying one is how lines are wrapped by
introducing more lines.  There doesn't seem to be support for HTML
tags either.

* Fix =evil-matchit=

Its author doesn't seem to be aware of idiomatic elisp at all, let
alone making it integrate properly into =evil=.  I could of course NIH
my own and replicate =matchit.vim= as closely as possible, but I'll
try out just how far I can go to make upstream improve it since these
complaints are fairly minor compared to the wrongdoings of =ace-jump=
for instance.

* Figure out how to break out of =evil='s type system

While it is convenient to have operators and motions to just work with
everything, some Vim plugins intentionally break the grammar to use
lesser common or nonsensical command sequences for their own
commands.  One of the better known examples would be =ysiw`= which
would normally do a yank operation, however in this context =ys=
introduces wrapping of a text object, in this case it's inside a word
and the wrapping is done with backquotes around it.

In Vim this kind of trick is done by carefully thinking up all key
sequences and binding the appropriate functions to them, essentially
overwriting the parts of the default bindings as necessary.  In =evil=
however there is no proper solution yet, so far upstream suggested
replacing an operator with a wrapper that calls the original one
unless one of the bindings is the one belonging to the nefarious
package.  It would be a lot better to have official access to this to
avoid endless cascades of wrappers outsmarting each other (it's not as
bad as in Win32 yet, but who knows how bad it will become).

* Discover worthwhile Vim plugins to turn into =evil= packages

Should be mostly editing-related hacks, such as replacing the =t=,
=T=, =f=, =F=, =,= , =;= motions with more powerful ones that are
between one-letter jumps and =ace-jump= style motion to arbitrary
one-letter jumps by allowing one to do two-letter jumps instead.

The rest is mostly improving Vim idiosyncracies (just like there's
stuff improving Emacs idiosyncracies) and packages that come somewhat
close to what already exists for Emacs (compare =fugitive= to =magit=
for instance).  Some exceptions are there though, such as the
excellent =yunocommit.vim= (see =company= for possible approaches to
overlays with images), a Flappy Bird clone and the powerline that
works in terminal emulators (the many Emacs ports only support
graphical instances since they actually draw bitmaps into the
modeline).

An =evil= state for ASCII drawing would be fun, much better than
arcane keybinds or ex commands.  Instead you'd have operators and
motions to edit and draw plus some commands to toggle stuff.

* Configure =smartparens= to start out with way less pairs

It's annoying to fix quotes for every Lisp-related mode (text-related
ones, too).  I'd prefer a default auto-indent function for braces.

* Integrate =smartparens= into =evil=

A separate =evil= state sounds best,
https://github.com/syl20bnr/evil-lisp-state demonstrates how it could
be done, however it regressed to accomodate for Lisp coding with
https://github.com/syl20bnr/evil-lisp-state/commit/fdddd81806ccbcad8cdf04edeb47816314bda8ae.

* Learn =smartparens= actions, do GIFcasts

There's a ton of them, but GIFcasts only for =paredit=.  Would be very
nice to have visual reminders for them, presumably lots of work, too.
=byzanz-record= to the rescue!

* Record GIFcasts for my own packages

Demonstrating eyebrowse commands would be quite cool (and an
improvement over the current "See that pretty indicator?  That's
eyebrowse!"), not sure how useful it would be for other packages.

* Set up an Emacs mail client

=mu4e= looks great, however the PKGBUILD on the AUR isn't updated
since the change that makes threading usable.  Another problem is
figuring out everything necessary to make mailing lists acceptable and
multiple accounts for /sending/ mail.  I'll need to keep it running
parallel to mutt for a good while to figure it all out, but then I'll
hopefully be able to reap the rewards such as no more encoding issues
and templates for mails (like, daily reports).

http://cmacr.ae/blog/2015/01/25/email-in-emacs/

* Hack more on =circe=

There's plenty on the issue tracker, asides from that I want to make
nick coloring more flexible by incorporating
https://github.com/TaylanUB/circe/commits/nick-colors/lisp/circe-color-nicks.el.

Another fun hack is displaying fools as XPM piggies instead of hiding
them, ideally with the toggle function doing a bit more work (by
traversing all circe buffers by looking for property changes involving
=lui-raw-text=) on every toggle.  The idea could be explored by
another hack that retroactively applies fool (maybe ignore, too?)
information.

I wish for hats to show up in the nicknames of messages, not only in
the initial listing.  The initial listing could come in sorted
alphabetically (instead of being sorted by join time?).  Working with
IRC commands would be cool (IIUC you have sort of a callback system
with commands and display handlers without the ability of determining
what request the response belongs to, so this requires guessing), such
as an /IDLE command (which uses the extended WHOIS form and snips out
the interesting field) or a module that "stalks" other people by
checking up whether they've joined recently and what channels they're
on (with the ISON command, maybe WHO as well).

* Configure =elfeed=

Now that I've configured =newsbeuter= to resemble other newsreaders
with grouped feeds, using =elfeed= should make a lot more sense for
me, especially after customizing it to be more flexible than it, like
by automatically marking everything older than a month as read.

* Hack on my own packages

=shackle= looks pretty much ok (except one open issue), =form-feed=
needs discussion on =emacs-devel= for figuring out the cursor kicking
issue, =gotham-theme= could use a lot more faces, =eyebrowse= is kind
of stalled and can get new features.

=quelpa= however could need love.

* Make =eshell= and its completion more usable

There's apparently no completion of arguments like in =zsh=.  Perhaps
a parser of its files could be built in, alternatively for =bash=.
Combined with =company-capf= this should make for very awesome
argument completion.

* Write tool for grepping Lisp code

The idea is that since Lisp code parses easily into a tree, one could
read in a file (and when necessary, uncompress it on the fly with
something like libarchive), parse it, then apply a shorthand
graph/tree querying language to find the interesting bits.

I don't know what kind of language though, possible inspirations are
CSS selectors, jQuery selectors, XPath/SXPath, Git/Mercurial Changeset
specifications, Gremlin, possibly many more.

It would be pretty snazzy to write it in CHICKEN, although there's
only separate eggs per decompression algorithm, like [[http://wiki.call-cc.org/eggref/4/z3][z3]].

* Write tool for analysis of Emacs sources

Would be very useful to be able to find function usage with something
a lot more usable than Regex-based solutions (like, tags), perhaps the
previously mentioned hypothetical tool would work.  Other stuff to
look for is library usage and making sure it can parse both libraries
and configurations for dependencies.

* Write a web UI to allow comparing differences between the library parts between Emacs releases

It would be very cool to find out what exactly breaks/improves between
Emacs releases and have an useful UI for browsing over it, sort of
like RDoc where you see docstrings and can fold out sources to peek at
the implementation.  Add diffing and a good overview and that should
be it.

* Write a web UI that unifies all popular package archives

It sucks that neither Marmalade nor MELPA are particularly good at
browsing and finding stuff easily.  Something like Vimawesome with
usage statistics would be very nice to have.  Discoverability FTW.

* Make news feeds for MELPA and Marmalade releases

There's currently twitter feeds that are mixed, not sure whether
there's anything for Marmalade even.  It would be useful to have one
for newly released packages and a separate one for their updates,
maybe even with Changelog links (either a commit summary or a file if
it exists with diffs).

* Bring =comint= hacks upstream

Despite =comint= feeling somewhat arcane, it is surprisingly useful
for anything REPL-like derived from it.  I have a few hacks in my
config that could very well make it upstream, such as history
wrap-around or partial buffer clearing.

There's other stuff I'd still like to do, such as persistent history
per buffer name/mode, similiar to what =rlwrap= does.  Maybe an
extension of that one hack started on the Stackexchange where I
truncated overly long lines and added an overlay to display the
original ones.

* Port major modes that ought to use =comint= to it

I'm not sure how much sense it would make for =eshell=.  But then I'd
at least not have to redo my hacks for it again.  Another candidate I
have in mind is =inf-ruby=.  Perhaps the interaction modes for
Clojure, CL and Scheme would benefit from it, too.

* Find =comint=-derived modes that could make use of syntax-highlighting

See http://emacs.stackexchange.com/questions/2293/change-syntax-highlighting-without-changing-major-mode

* Make =savehist= save more

See ~savehist-additional-variables~.

* Improve =package=

When it comes to its adherence to MVC, it's pretty terrible (you need
to open the view before you're able to do anything beyond installing a
package blindly) and lacks a good amount of functionality you'd just
expect to be there (nothing to view changelogs, previewing packages,
removing packages outside the view, searching dependencies, etc.).
There's plenty other problems lurking in there including installation
bugs.

* Fix spamming bugs for =rcirc= (and ERC?)

There's at the very least a bug making RET RET on the nicklist in
=rcirc= send the entire nicklist to the channel.  One possible
solution would be special-casing the nicklist, a more general one
would involve a paste protection for both long messages and messages
containing newlines with tresholds for both.

* Write package for hacking on keymaps

There's nothing just previewing them properly or more than the bare
minimum for creating them.  Just doing some research on those and
nice-to-haves would be nice for a blog.

* Explore Hydra a bit more

I've replaced my =helm-fkeys= package successfully with it, however
its aspect of repeatable actions definitely sounds interesting, too.
Obvious candidates would be window resizing and font size changes,
perhaps other stuff like =macrostep= as well.

* Start an Emacs Blog

I've always wanted to do a technical blog, but it will very likely be
mostly about Emacs which is totally fine.  Interludes about other Lisp
dialects, Arch Linux and general Software Engineering would be pretty
cool.  I have a 90% finished blog engine, completing it would solve
the technical issues, as domain I've chosen http://emacsninja.com/
(because there's this one fun article about ninjas and pirates using
Vim and Emacs at
http://philosecurity.org/2009/03/23/pirates-and-ninjas-emacs-or-vi
which I will of course elaborate upon in its About page).  The design
is something I'm less sure about, but I'd love incorporating modelines
or just flatout stealing from http://emacsrocks.com/.

* Finish up nekobot

I've started writing a bot using [[https://github.com/jorgenschaefer/circe][Circe]], my prefered IRC client.  Two
unexpected difficulties cropped up though, for one I didn't find any
ready-made library to select parts of html (which would have been
necessary to write extensions dealing with web services), the other
one is that its author decided to rewrite its internals after hearing
of my endeavor.  Once that rewrite is fully done (most of it is,
there's tests and bugs to be fixed), writing a bot should become
simpler.

* Implement zippers in elisp

https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
https://clojure.github.io/clojure/clojure.zip-api.html
https://github.com/danielfm/cl-zipper
https://bitbucket.org/DerGuteMoritz/zipper/src
http://paste.call-cc.org/paste?id=c7b2e8dfde5105479490af2d3ca942b8a6ef519f#a1

These look pretty great for traversing trees in a lispy manner (and
even modifying them!) and simple to implement.  I'll probably steal
the API from Clojure and implement them with as little recursion as
possible (as demonstrated by the very basic cl-zipper).  A =zip-=
namespace for the generic functions should work (though, hmm, I could
steal the still unused =z.el=...), additionally to that an
=esxml-zip-= namespace for the esxml-specific things to have (and
aliases to everything else?).  In case I shouldn't like them (even
with threading macros), a function compiling a CSS selector to a list
of zipper instructions should do the trick.

* Write a package for annotating all kinds of human-readable files

This is a pretty popular request, I should research into existing
solutions for Emacs first.  One half seems to be focused on linking
org captures to files which is a hack at best, the other half actually
puts some UI over the original buffer with overlays (but is dead).

https://code.google.com/p/annot/
https://github.com/emacsmirror/annotate/blob/master/annotate.el
https://github.com/GoNZooo/annotate

https://github.com/VincentToups/emacs-utils/blob/master/annotate.el
http://orgmode.org/w/?p=org-mode.git;a=blob_plain;f=contrib/lisp/org-annotate-file.el;hb=HEAD
https://github.com/tarsius/orglink
https://github.com/girzel/org-annotate

The UI can be stolen from Google Docs or Genius (select a range of
text, enter annotation in a commit-style buffer, save/discard, see a
highlighted range in the original buffer).  What I'm less sure about
is for one the storage place of such annotations (in the same place
with an appended extension or in a central directory generating
subdirectories as needed?), the storage type (serializing a data
structure will require defining a stable format to avoid version
mismatches) and the way these annotations can be displayed
(minibuffer, pop to buffer, tooltip, right margin, inline, etc.) and
edited (like the commit buffers?).  How useful it would be in practice
would be the other question, both because I can't imagine using it
excessively and because overlays are known to cause performance issues
(which [[https://lists.gnu.org/archive/html/emacs-devel/2014-09/msg00616.html][won't be addressed]] for now).

No idea about the name (never-knows-best?).
