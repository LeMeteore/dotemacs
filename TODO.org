* Fix Emacs' selection after window quit/close

So very annoying.  Apparently switching window focus after creating
window splits somehow causes a window kill to not select the window's
parent anymore, but instead selects a different window.

Repro: =C-x 3 C-x o C-x o C-x 2 C-x 0=

Result: Switches focus to the other split side instead of the parent
window.

Very likely to be something within ~delete-window-internal~.

* Fix Emacs' window quitting behaviour

This seems to pose a significant issue for implementing interfaces
that pop up buffers and need quitting to just work.  It would be
obvious to implement a FIFO-like structure (see
http://sprunge.us/aGHM), but that's not how it works.  =(info "(elisp)
Window Parameters")= should have the relevant information on
influencing this behaviour.

* Investigate in =recentf= truncation behaviour

Something about it feels off.  It's supposed to remove duplicate
entries first, then truncate if it's still too long, but it feels like
despite a fairly high history length it truncates too many recent
files.  In other words, I want a behaviour comparable to =zsh= and its
history pruning.  In case that's not the reason for it, I'll probably
just increase the history limit to a ridiculously large number.

* Join forces with Fuco and think up better names for the projects to hack on

The plan is to do a Github organization and to learn useful stuff
along the way, such as advanced =dash= usage, EIEIO (an undebuggable
partial implementation of the infamous CLOS) and more abstractions.
The general plan is to reimplement sane subsets of popular packages
since those are assumed to be unfixable with a few pull requests, such
as =helm=, =ace-jump= and many more.

As for the name of this organization, I plead for =tetracat= and
either http://brause.cc/tetracat.jpg or a derived work.  Should be
only a matter of time with a graphics tablet and either Inkscape or
Krita.

* Rewrite a sane subset of =helm=

Let's call it =union= (since there's =unite= for Vim and it's one char
shorter, also there's this very pretty kind of union-jack segment LEDs
of which I happen to have an appropriate animated GIF for).

* Rewrite a sane subset of =dired=

Let's call it =rind= (for =rind= Is Not =dired= or =ranger=-INspired
=dired=).  The reason why should be obvious, =dired='s method of
getting file information by parsing =ls= output is brittle and it's
surprisingly hard to extend.  I really like =ranger=, but it does
neither live within Emacs nor is it able to be extended with elisp.
Fuco's =etable= looks like a good starting place for writing the UI.

* Rewrite a sane subset of =tramp=

I'm not even sure whether that's a good idea at all, let alone how to
test such a thing considering I don't have many remote boxes to try it
on (or to be more precise, just a single one).  It could very well be
that my issues with it arise from its implicit integration into Emacs.

* Rewrite =calfw=

It is pretty much impossible to understand and has bizarre bugs (like,
quitting fucks up position of the window point in the last buffer).
Also, writing your own calendar seems to be good tradition to
experience the many falsehoods programmers believe in about time and
dates yourself.

* Make a list of (REPL) modes to enable =company= for

Stuff like =ielm= would qualify.  Perhaps some textual modes, too.

* TODO Improve elisp completion in =company=

There are a few corner cases (with =company-elisp=, check whether they
are still present in =company-capf=), fix those (TODO list them).
Additionally to that it would be very cool to have contextual
completion inside macros, like ~loop~ to get the loop keywords as
candidates.

* Learn how =company-capf= works

The elisp backend was replaced by it in 24.4, its code should tell me
enough about the effort involved in getting other backends to use it.
Porting the other ones over will give me completion styles.

* Integrate =yasnippet= into =company=

=company-yasnippet= looks pretty snazzy, the only thing preventing me
from using it is that the official documentation suggests making
=company-backends= buffer-local and change its value in every mode
making use of snippets.

* Write own snippets

I've installed =yasnippet= because at that time I had to write Java
code in a course and didn't feel like using Eclipse.  The default
snippets are a bit problematic though, especially the ones used for
elisp code because they're very short and get triggered even if I
hadn't inserted the text beforehand, so hitting TAB in an already
written line at an arbitrary position where the text before point
makes up a valid snippet abbreviation triggers it.  That's definitely
not ok, part of the solution would be writing my own, the other would
be giving them longer names suitable for tab-completion via =company=.

* Learn the =yasnippet= syntax

http://capitaomorte.github.io/yasnippet/snippet-development.html

* Write a =flx=-like completion style

While there's already =flx= code, I need to find out how completion
styles are implemented and check how slow they'd be with =flx= as is.
If it's not fast enough, write a binary component in CHICKEN and make
it flexible enough for more than just that.

* Reuse binary component from above for =helm= / =ido= matching

This would solve the problem of not having nice and fast flex matching
à la Sublime Text.  The key to this is the combination of fast
submatching (heatmap + optimization that makes use of the reuse of the
string since you usually append a glyph at a time and therefore don't
need to start all over again) as in
http://hergert.me/blog/2013/09/13/fuzzy-searching.html and sorting of
the candidates by criteria that make matches for word boundaries
appear at the top.  I'm afraid the hard part would be rather
integrating it in these tools than writing it.

* Write a pure elisp torrent client

Sounds like a pretty hefty exercise considering a network process that
errors out can cause Emacs to hang up and it doesn't have the
facilities required for writing sparse files exposed (yet, I've found
internal C functions for advancing to arbitrary positions in files,
see =fileio.c= when searching for =lseek=).  It would probably be more
useful to write a proper frontend to an existing torrent client.

* Help out holomorph with his =transmission= UI

Unlike the previous entry this sounds very doable and profitable.

* Fix long lines bug

Oh boy.  My main idea how to fix this properly relies on section 6.3
of
http://soft-dev.org/pubs/html/diekmann_tratt__eco_a_language_composition_editor/.
In other words, keeping track of visual line breaks, using them to
speed up rendering and keeping them up to date.  This will obviously
require hacking on the buffer data structure.

* Write a proper CSV viewer/editor

Until that long lines bug is fixed, viewing CSV files is no fun.  To
remedy it for now I thought of writing something like a mixture of
=tabview= and =sc= (and call it =sv-mode= because it's for separated
values).  In other words this displays a truncated viewport where you
can scroll through cells and offers keybinds to edit rows and columns
or change the view to something more useful (such as sorting,
filtering, etc.).

* Write some more graphical games

I've had enough fun with SVG (although I should at least finish up the
animation part in =svg-2048=), XPM would be the next thing I'd tackle
(for something like Conway's Game of Life).  By then I should have a
good idea what's better to use and could proceed with other fun games,
such as clones of =xeyes=, =breakout=, =tetris= (replicating TGM3 would
be very cool), something like Tower Defense.  Maybe something
demo-like with procedural graphics.  Maybe go more abstract and whip
up everything necessary to do more advanced games, like stuff
reminiscent of visual novels (although, would they work without
sound?), platformers, bullethell shmups, etc.  Who knows whether one
of those might become the next Emacs killer app.

* Write graphical demos

So far I had a flipbook (see the Quasiconf 2014 files), this could be
abstracted into a video player (which converts the video into frames
beforehand, mind you).  A pixelart editor would be very cool,
especially for things like my demo on http://brause.cc/.  GIF editing
by wrapping =gifsicle= and inserting the created previews could be
better than what Photoshop and GIMP offer.  A fully-featured
SVG/Bitmap editor would be more utopian, but the groundwork for that
is laid with the =svg.el= package (which could become a fast
canvas-like) and proper bitmap embedding support in Emacs 25.1.

* Create my own starter kit

HollywoodOS™ with SVG and something terminal-looking with lots of text
over it would be a really silly one.  So would be a 1984 one that
makes Emacs look and behave even more arcane than usual (with reduced
colors and all that).

* Write a fast terminal emulator

Perhaps with FFI (not sure whether the official one or skeeto's
approach) and libtsm one could write something considerably faster
than ~ansi-term~, probably not though.

* Write audio demos

This doesn't work very well with external processes at the moment,
though my demo with Overtone for Quasiconf 2014 showed promise.  FFI
might solve it (or not).  It would be super-cool to have something
like a keyboard to play melodies, ideally by driving CSound instead of
Supercollider.  It would be even more cool to turn it into a
keyboard-driven tracker to compose music and tweak synths or create
samples to play.

* Work on helm packages

I'm less happy about =helm-smex=.  It would be a lot better to add a
helm interface to smex directly instead of hacking something that
reuses the data the ido interface creates.

As for new packages using =helm=, I'd like having something slightly
better than my current setup with =dmenu= driving =mpd=.  Another
thing that would be cool to have would be an interface to
http://dict.cc/ and its offline dictionaries with history.  Searching
the package archives and AUR would be better than the Web UI.  Perhaps
replacing all of my search engine usage if it proves to be better
(incremental completion is the problem).  Oh and full-text search on
info manuals, it would be enough to be able to use it on the currently
open node and its children.

* Bump bug reports without replies

According to Eli Zaretskii this should be alright to do after a week
without replies.

* Hand in a bug for ~browse-url-can-use-xdg~

This function is not reliable as it only works on a few select Desktop
Environments and essentially replicates what =xdg-open= is doing
already in a less complete fashion.  Before handing in the bug I've
got to find out how to detect it working in a better fashion.  My
rather naïve assumption would be that if there is such a binary, the
Xorg session is running and executing it gives me a return code of
zero, everything's fine.

* Send in a patch for ~debug-setup-buffer~

I've figured out that when evaluating a buffer, this function inserts
the buffer position where the error occurs.  It is possible to turn
that into a line number, making it a button that takes you to the file
would be pretty cool and surely a good candidate for a patch and
mailing list discussion since it makes the =--debug-init= option more
useful.

* Discuss =--debug-init= and why it's not a default

Another candidate for the mailing list.  I am still dumbfounded how
one starts Emacs, gets an error at start, then is told to quit and
start it again with that option to get a backtrace.  Why isn't this
option made default?  There doesn't seem to be any performance
penalty, it can be deactivated after successful init and for the very
unlikely situation that there is stuff relying on it not spawning the
debugger (instead of a generic error window) like batch processing, a
new option to deactivate it could be introduced instead (and the
option itself be deprecated by making it a no-op).

* Investigate into the debugger to make it better

I don't know much about the keybindings yet and am much more
acquainted with =edebug= unfortunately.  Finding out how the =debug=
works would be very cool since it seems to always work, there have
been a few posts about stackframes on the stackexchange.

There is a wonderful screenshot of a Lisp machine where the debugger
runs into a division by zero and displays the faulty expression with
the form causing the error highlighted in bold.  That sounds even
better than displaying a line number and button to jump to since
evaluation does not necessarily happen to a file.

Another thing I'd like to see would be backtraces with less bytecode
in them, for both aesthetical (they take up loads more screen estate)
and practical (they break copy-paste on a null byte for me) reasons.
It is possible to re-evaluate a function to obtain prettier display of
its forms, with byte-compilation most of these are lost.

The not so S-Expression-like display of the stackframes isn't ideal
either, it looks more like functions in other languages than something
lispy.  Why they did that is beyond me.

* Report bugs for not properly derived modes

There are a bunch of modes that ought to be derived from ~text-mode~
and ~prog-mode~, but aren't.  All of those should be reported to make
my hooks section cleaner.

* Discuss why ~package-initialize~ is used after init

It's very likely to be the first line in the dotemacs of anyone using
Marmalade/MELPA.  So, why not cater for it and remove the surprise
element considering how often it crops up?   The ensuing discussion on
the mailing list might be fun.

* Rediscover =org-mode= again after having learned elisp

I've stayed away from =org-mode= from everything else asides note
taking and keeping track of things in README-style files since the
configuration and elisp involved scared me off.  However I'm armed
with everything necessary to embark this part of my Emacs journey
again, so why not go through the agenda, refiling, clocking and many
more to keep track of things again?

* Figure out how =evil= works

All I know so far from cursory glances at the sources is that it does
black magic on keymaps, appears to have implemented a type system for
editing commands with elisp macros and has an actually proper looking
parser for ex commands.  This is kind of intriguing and surely a good
chance to learn advanced concepts.

However the documentation is a bit lacking when it comes to extending
it.  Another issue is that several critical variables are empty at
definition, but filled after startup.  Therefore combined reading of
the sources and inspection of variables while it's running are
necessary to gain understanding in its inner workings.

* Fix =evil-surround=

Its commands are not repeatable which sucks since they are
comparatively long.  Another annoying one is how lines are wrapped by
introducing more lines.  There doesn't seem to be support for HTML
tags either.

* Fix =evil-matchit=

Its author doesn't seem to be aware of idiomatic elisp at all, let
alone making it integrate properly into =evil=.  I could of course NIH
my own and replicate =matchit.vim= as closely as possible, but I'll
try out just how far I can go to make upstream improve it since these
complaints are fairly minor compared to the wrongdoings of =ace-jump=
for instance.

* Figure out how to break out of =evil='s type system

While it is convenient to have operators and motions to just work with
everything, some Vim plugins intentionally break the grammar to use
lesser common or nonsensical command sequences for their own
commands.  One of the better known examples would be =ysiw`= which
would normally do a yank operation, however in this context =ys=
introduces wrapping of a text object, in this case it's inside a word
and the wrapping is done with backquotes around it.

In Vim this kind of trick is done by carefully thinking up all key
sequences and binding the appropriate functions to them, essentially
overwriting the parts of the default bindings as necessary.  In =evil=
however there is no proper solution yet, so far upstream suggested
replacing an operator with a wrapper that calls the original one
unless one of the bindings is the one belonging to the nefarious
package.  It would be a lot better to have official access to this to
avoid endless cascades of wrappers outsmarting each other (it's not as
bad as in Win32 yet, but who knows how bad it will become).

* Discover worthwhile Vim plugins to turn into =evil= packages

Should be mostly editing-related hacks, such as replacing the =t=,
=T=, =f=, =F=, =,= , =;= motions with more powerful ones that are
between one-letter jumps and =ace-jump= style motion to arbitrary
one-letter jumps by allowing one to do two-letter jumps instead.

The rest is mostly improving Vim idiosyncracies (just like there's
stuff improving Emacs idiosyncracies) and packages that come somewhat
close to what already exists for Emacs (compare =fugitive= to =magit=
for instance).  Some exceptions are there though, such as the
excellent =yunocommit.vim= (see =company= for possible approaches to
overlays with images), a Flappy Bird clone and the powerline that
works in terminal emulators (the many Emacs ports only support
graphical instances since they actually draw bitmaps into the
modeline).

An =evil= state for ASCII drawing would be fun, much better than
arcane keybinds or ex commands.  Instead you'd have operators and
motions to edit and draw plus some commands to toggle stuff.

* Get rid of =evil-leader=

It didn't occur me back then that I don't need it at all.  The only
benefit is configurability in case should I ever change the leader
prefix, but that's rather unlikely and can already be done with a
variable.

* Configure =smartparens= to start out with way less pairs

It's annoying to fix quotes for every Lisp-related mode (text-related
ones, too).  I'd prefer a default auto-indent function for braces.

* Integrate =smartparens= into =evil=

A separate =evil= state sounds best,
https://github.com/syl20bnr/evil-lisp-state demonstrates how it could
be done, however it regressed to accomodate for Lisp coding with
https://github.com/syl20bnr/evil-lisp-state/commit/fdddd81806ccbcad8cdf04edeb47816314bda8ae.

* Learn =smartparens= actions, do GIFcasts

There's a ton of them, but GIFcasts only for =paredit=.  Would be very
nice to have visual reminders for them, presumably lots of work, too.
=byzanz-record= to the rescue!

* Set up an Emacs mail client

=mu4e= looks great, however the PKGBUILD on the AUR isn't updated
since the change that makes threading usable.  Another problem is
figuring out everything necessary to make mailing lists acceptable and
multiple accounts for /sending/ mail.  I'll need to keep it running
parallel to mutt for a good while to figure it all out, but then I'll
hopefully be able to reap the rewards such as no more encoding issues
and templates for mails (like, daily reports).

http://cmacr.ae/blog/2015/01/25/email-in-emacs/

* Hack more on =circe=

There's plenty on the issue tracker, asides from that I want to make
nick coloring more flexible by incorporating
https://github.com/TaylanUB/circe/commits/nick-colors/lisp/circe-color-nicks.el.

* Configure =elfeed=

Now that I've configured =newsbeuter= to resemble other newsreaders
with grouped feeds, using =elfeed= should make a lot more sense for
me, especially after customizing it to be more flexible than it, like
by automatically marking everything older than a month as read.

* Hack on my own packages

=shackle= looks pretty much ok (except one open issue), =form-feed=
needs discussion on =emacs-devel= for figuring out the cursor kicking
issue, =gotham-theme= could use a lot more faces, =eyebrowse= is kind
of stalled and can get new features.

=quelpa= however could need love.

* Make =eshell= and its completion more usable

There's apparently no completion of arguments like in =zsh=.  Perhaps
a parser of its files could be built in, alternatively for =bash=.
Combined with =company-capf= this should make for very awesome
argument completion.

* Write tool for grepping Lisp code

The idea is that since Lisp code parses easily into a tree, one could
read in a file (and when necessary, uncompress it on the fly with
something like libarchive), parse it, then apply a shorthand
graph/tree querying language to find the interesting bits.

I don't know what kind of language though, possible inspirations are
CSS selectors, jQuery selectors, XPath/SXPath, Git/Mercurial Changeset
specifications, Gremlin, possibly many more.

It would be pretty snazzy to write it in CHICKEN, although there's
only separate eggs per decompression algorithm, like [[http://wiki.call-cc.org/eggref/4/z3][z3]].

* Write tool for analysis of Emacs sources

Would be very useful to be able to find function usage with something
a lot more usable than Regex-based solutions (like, tags), perhaps the
previously mentioned hypothetical tool would work.  Other stuff to
look for is library usage and making sure it can parse both libraries
and configurations for dependencies.

* Write a web UI to allow comparing differences between the library parts between Emacs releases

It would be very cool to find out what exactly breaks/improves between
Emacs releases and have an useful UI for browsing over it, sort of
like RDoc where you see docstrings and can fold out sources to peek at
the implementation.  Add diffing and a good overview and that should
be it.

* Write a web UI that unifies all popular package archives

It sucks that neither Marmalade nor MELPA are particularly good at
browsing and finding stuff easily.  Something like Vimawesome with
usage statistics would be very nice to have.  Discoverability FTW.

* Make news feeds for MELPA and Marmalade releases

There's currently twitter feeds that are mixed, not sure whether
there's anything for Marmalade even.  It would be useful to have one
for newly released packages and a separate one for their updates,
maybe even with Changelog links (either a commit summary or a file if
it exists with diffs).

* Bring =comint= hacks upstream

Despite =comint= feeling somewhat arcane, it is surprisingly useful
for anything REPL-like derived from it.  I have a few hacks in my
config that could very well make it upstream, such as history
wrap-around or partial buffer clearing.

There's other stuff I'd still like to do, such as persistent history
per buffer name/mode, similiar to what =rlwrap= does.  Maybe an
extension of that one hack started on the Stackexchange where I
truncated overly long lines and added an overlay to display the
original ones.

* Port major modes that ought to use =comint= to it

I'm not sure how much sense it would make for =eshell=.  But then I'd
at least not have to redo my hacks for it again.  Another candidate I
have in mind is =inf-ruby=.  Perhaps the interaction modes for
Clojure, CL and Scheme would benefit from it, too.

* Find =comint=-derived modes that could make use of syntax-highlighting

See http://emacs.stackexchange.com/questions/2293/change-syntax-highlighting-without-changing-major-mode

* Make =savehist= save more

See ~savehist-additional-variables~.

* Improve =package=

When it comes to its adherence to MVC, it's pretty terrible (you need
to open the view before you're able to do anything beyond installing a
package blindly) and lacks a good amount of functionality you'd just
expect to be there (nothing to view changelogs, previewing packages,
removing packages outside the view, searching dependencies, etc.).
There's plenty other problems lurking in there including installation
bugs.

* Write package for hacking on keymaps

There's nothing just previewing them properly or more than the bare
minimum for creating them.  Just doing some research on those and
nice-to-haves would be nice for a blog.

* Explore Hydra a bit more

I've replaced my =helm-fkeys= package successfully with it, however
its aspect of repeatable actions definitely sounds interesting, too.
Obvious candidates would be window resizing and font size changes,
perhaps other stuff like =macrostep= as well.

* Integrate =macrostep= into =evil=

For yet unknown reasons =macrostep= can only be used in Emacs state.
Figuring out its hook and using ~evil-normalize-keymaps~ should do the
trick, but it doesn't.

* Start an Emacs Blog

I've always wanted to do a technical blog, but it will very likely be
mostly about Emacs which is totally fine.  Interludes about other Lisp
dialects, Arch Linux and general Software Engineering would be pretty
cool.  I have a 90% finished blog engine, completing it would solve
the technical issues, as domain I've chosen http://emacsninja.com/
(because there's this one fun article about ninjas and pirates using
Vim and Emacs at
http://philosecurity.org/2009/03/23/pirates-and-ninjas-emacs-or-vi
which I will of course elaborate upon in its About page).  The design
is something I'm less sure about, but I'd love incorporating modelines
or just flatout stealing from http://emacsrocks.com/.

* Start an Emacs Microblog

This is slightly different from above.  I keep encountering really
weird/scary code in Emacs' codebase and would like to have something
like http://whattheemacsd.com/ or the http://opensslrampage.org/ or
http://geoff.greer.fm/vim/#realwaitforchar.
